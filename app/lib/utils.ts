import { JsonMetadata, Metaplex } from "@metaplex-foundation/js";
import { web3, utils } from "@project-serum/anchor";
import axios from "axios";

import { StakeReceipt } from "./gen/accounts";
import { fromTxError } from "./gen/errors";
import { PROGRAM_ID } from "./gen/programId";
import { findFarmerAddress } from "./pda";

type ProgramAccounts = {
  pubkey: web3.PublicKey;
  account: web3.AccountInfo<Buffer>;
};

interface Attribute {
  trait_type: string;
  value: string;
}

const BUFF_ATTRIBUTE: Attribute = {
  trait_type: "Essence",
  value: "Set",
};

export const hasBuffAttribute = async (
  connection: web3.Connection,
  mintAddress: web3.PublicKey
): Promise<boolean> => {
  try {
    const { uri } = await Metaplex.make(connection)
      .nfts()
      .findByMint({ mintAddress })
      .run();
    const { data, status } = await axios.get<JsonMetadata>(uri);
    if (status !== 200)
      throw new Error(
        `Failed to fetch off-chain metadata for mint ${mintAddress}.`
      );

    return data.attributes?.some((a) => a === BUFF_ATTRIBUTE);
  } catch {
    return false;
  }
};

export const findUserStakeReceipts = async (
  connection: web3.Connection,
  farm: web3.PublicKey,
  userPublicKey: web3.PublicKey
): Promise<StakeReceipt[]> => {
  const farmer = findFarmerAddress({ farm, owner: userPublicKey });

  const filters = [
    accountFilter(StakeReceipt.discriminator),
    memcmp(8, farmer.toString()),
  ];

  const accounts = await fetchAccounts(connection, filters);

  return Promise.all(
    accounts.map(async (account) => {
      return StakeReceipt.decode(account.account.data);
    })
  );
};

export type FoundCreator = {
  metadataAddress: web3.PublicKey;
  creatorAddress: web3.PublicKey;
};

export const tryFindCreator = async (
  connection: web3.Connection,
  mintAddress: web3.PublicKey
): Promise<FoundCreator | null> => {
  try {
    const { creators, metadataAddress } = await Metaplex.make(connection)
      .nfts()
      .findByMint({ mintAddress })
      .run();

    const creatorAddress = creators.find((c) => c.verified).address;

    return { creatorAddress, metadataAddress };
  } catch (e) {
    return;
  }
};

// Helper function to handle the errors generated by the program.
export function withParsedError<T, U>(
  fn: (...args: T[]) => Promise<U>
): (...args: T[]) => Promise<U> {
  return async function (...args: T[]) {
    try {
      return await fn(...args);
    } catch (e) {
      const parsed = fromTxError(e);

      if (parsed != null) {
        throw parsed;
      }

      throw e;
    }
  };
}

const memcmp = (offset: number, bytes: string): web3.MemcmpFilter => {
  return {
    memcmp: {
      offset,
      bytes,
    },
  };
};

const accountFilter = (discriminator: Buffer) => {
  return memcmp(0, utils.bytes.bs58.encode(discriminator));
};

const fetchAccounts = (
  connection: web3.Connection,
  filters: web3.GetProgramAccountsFilter[]
): Promise<ProgramAccounts[]> => {
  return connection.getProgramAccounts(PROGRAM_ID, {
    encoding: "base64",
    filters,
  });
};

export const findAllStakeReceipts = async (
  connection: web3.Connection
): Promise<StakeReceipt[]> => {
  const filters = [accountFilter(StakeReceipt.discriminator)]

  const accounts = await fetchAccounts(connection, filters)

  const mapped = accounts
    .map((account) => {
      try {
        return StakeReceipt.decode(account.account.data)
      } catch (e) {
        return null
      }
    })
    .filter((value) => value !== null)

  return mapped
}