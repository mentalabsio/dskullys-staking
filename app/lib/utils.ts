import {Metaplex} from "@metaplex-foundation/js";
import {web3, utils} from "@project-serum/anchor";

import {Lock, StakeReceipt} from "./gen/accounts";
import {fromTxError} from "./gen/errors";
import {PROGRAM_ID} from "./gen/programId";
import {findFarmerAddress} from "./pda";

type ProgramAccounts = {
  pubkey: web3.PublicKey;
  account: web3.AccountInfo<Buffer>;
};

type LockAccount = Lock & {address: web3.PublicKey};

export const findFarmLocks = async (
  connection: web3.Connection,
  farm: web3.PublicKey
): Promise<LockAccount[]> => {
  const dataSize = 8 + Lock.layout.span;
  const filters = [
    {dataSize},
    accountFilter(Lock.discriminator),
    memcmp(8, farm.toBase58()),
  ];

  const accounts = await fetchAccounts(connection, filters);

  return Promise.all(
    accounts.map(async ({pubkey, account}) => {
      return Object.assign(Lock.decode(account.data), {address: pubkey});
    })
  );
};

export const findUserStakeReceipts = async (
  connection: web3.Connection,
  farm: web3.PublicKey,
  userPublicKey: web3.PublicKey
): Promise<StakeReceipt[]> => {
  const farmer = findFarmerAddress({farm, owner: userPublicKey});

  const filters = [
    accountFilter(StakeReceipt.discriminator),
    memcmp(8, farmer.toString()),
  ];

  const accounts = await fetchAccounts(connection, filters);

  return Promise.all(
    accounts.map(async (account) => {
      return StakeReceipt.decode(account.account.data);
    })
  );
};

export type FoundCreator = {
  metadataAddress: web3.PublicKey;
  creatorAddress: web3.PublicKey;
};

export const tryFindCreator = async (
  connection: web3.Connection,
  mintAddress: web3.PublicKey
): Promise<FoundCreator | null> => {
  try {
    const {creators, metadataAddress} = await Metaplex.make(connection)
      .nfts()
      .findByMint({mintAddress})
      .run();

    const creatorAddress = creators.find((c) => c.verified).address;

    return {creatorAddress, metadataAddress};
  } catch (e) {
    return;
  }
};

// Helper function to handle the errors generated by the program.
export function withParsedError<T, U>(
  fn: (...args: T[]) => Promise<U>
): (...args: T[]) => Promise<U> {
  return async function (...args: T[]) {
    try {
      return await fn(...args);
    } catch (e) {
      const parsed = fromTxError(e);

      if (parsed != null) {
        throw parsed;
      }

      throw e;
    }
  };
}

const memcmp = (offset: number, bytes: string): web3.MemcmpFilter => {
  return {
    memcmp: {
      offset,
      bytes,
    },
  };
};

const accountFilter = (discriminator: Buffer) => {
  return memcmp(0, utils.bytes.bs58.encode(discriminator));
};

const fetchAccounts = (
  connection: web3.Connection,
  filters: web3.GetProgramAccountsFilter[]
): Promise<ProgramAccounts[]> => {
  return connection.getProgramAccounts(PROGRAM_ID, {
    encoding: "base64",
    filters,
  });
};
